<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mysql学习 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="常用工具 mysql  语法: mysql [options] [database] -u 用户名 -p 密码 -h 服务器ip -P 端口 -e 执行sql语句并退出 例mysql -uroot -p123456 数据库 -e &quot;selet * from table&quot;      sql执行顺序from-where-group by-having-select-order by">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql学习">
<meta property="og:url" content="http://example.com/2022/09/09/mysql%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="常用工具 mysql  语法: mysql [options] [database] -u 用户名 -p 密码 -h 服务器ip -P 端口 -e 执行sql语句并退出 例mysql -uroot -p123456 数据库 -e &quot;selet * from table&quot;      sql执行顺序from-where-group by-having-select-order by">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-09-09T12:46:02.000Z">
<meta property="article:modified_time" content="2022-09-09T12:46:49.897Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/butterfly-icon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/09/09/mysql%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-09 20:46:49'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hexo</span></a><a class="nav-page-title" href="/"><span class="site-name">mysql学习</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">mysql学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-09-09T12:46:02.000Z" title="Created 2022-09-09 20:46:02">2022-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-09-09T12:46:49.897Z" title="Updated 2022-09-09 20:46:49">2022-09-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><ul>
<li><p>mysql</p>
<ul>
<li>语法: mysql [options] [database]<ul>
<li>-u 用户名</li>
<li>-p 密码</li>
<li>-h 服务器ip</li>
<li>-P 端口</li>
<li>-e 执行sql语句并退出 例<code>mysql -uroot -p123456 数据库 -e &quot;selet * from table&quot;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="sql执行顺序"><a href="#sql执行顺序" class="headerlink" title="sql执行顺序"></a>sql执行顺序</h2><p>from-where-group by-having-select-order by-limit</p>
<h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><ul>
<li>脏读：事务读到了另一个事务未提交的数据。</li>
<li>不可重复读：事务先后读取同一条记录，但读取的数据不同。</li>
<li>幻读：事务在查询数据时没有记录，但插入数据时又提示记录已经存在。</li>
</ul>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li>read uncommitted：三个并发问题会出现</li>
<li>read commited：一个事务提交后，另一个事务才会看到提交后的数据，否则看到的是旧数据。解决了脏读，但会出现不可重复读，和幻读。</li>
<li>repeatable read(默认)：事务操作时的数据都是旧数据，即使另一个事务提交了新数据。解决了不可重复读。</li>
<li>serializable：数据操作只能一个事务来进行，另一个事务只能等待。</li>
</ul>
<p>查看事务隔离级别<code>select @@transaction_isolation</code></p>
<p>设置事务隔离级别<code>set session transaction isolation level 隔离级别</code></p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL体系结构：</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220816211452023.png" alt="image-20220816211452023"><br><img src="https://dhc.pythonanywhere.com/media/editor/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89_20220315034359342837.png" alt="层级描述"></p>
<p>&#x3D;&#x3D;存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎&#x3D;&#x3D;。<br>默认存储引擎是InnoDB。</p>
<p>查看建表引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure>

<p>查看数据库支持的引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p>创建表时指定存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表明&#123;</span><br><span class="line">	字段</span><br><span class="line">&#125; engine <span class="operator">=</span> 引擎;</span><br></pre></td></tr></table></figure>



<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p>
<p>特点：</p>
<ul>
<li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li>
<li><strong>行级锁</strong>，提高并发访问性能</li>
<li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li>
</ul>
<p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p>
<p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p>
<p>值为打开时，表示每张表对应一个表空间</p>
<p>InnoDB 逻辑存储结构：</p>
<p>区：1M</p>
<p>&#x3D;&#x3D;页：16K&#x3D;&#x3D;</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220816211507890.png" alt="image-20220816211507890"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p>
<p>特点：</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>xxx.MYD: 存储数据</li>
<li>xxx.MYI: 存储索引</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点：</p>
<ul>
<li>存放在内存中，速度快</li>
<li>hash索引（默认）</li>
</ul>
<p>文件：</p>
<ul>
<li>xxx.sdi: 存储表结构信息</li>
<li>因为存放在内存中，所以没有文件来存储数据和索引</li>
</ul>
<h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
<th align="left">Memory</th>
</tr>
</thead>
<tbody><tr>
<td align="left">存储限制</td>
<td align="left">64TB</td>
<td align="left">有</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left">事务安全</td>
<td align="left">支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">锁机制</td>
<td align="left">行锁</td>
<td align="left">表锁</td>
<td align="left">表锁</td>
</tr>
<tr>
<td align="left">B+tree索引</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">Hash索引</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">全文索引</td>
<td align="left">支持（5.6版本之后）</td>
<td align="left">支持</td>
<td align="left">-</td>
</tr>
<tr>
<td align="left">空间使用</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">N&#x2F;A</td>
</tr>
<tr>
<td align="left">内存使用</td>
<td align="left">高</td>
<td align="left">低</td>
<td align="left">中等</td>
</tr>
<tr>
<td align="left">批量插入速度</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">支持外键</td>
<td align="left">支持</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<ul>
<li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li>
<li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。(现在主要被mongodb替代)</li>
<li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。(现在主要被redis替代)</li>
</ul>
<p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p>
<p>优缺点：</p>
<p>优点：</p>
<ul>
<li>提高数据检索效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引列也是要占用空间的</li>
<li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li>
</ul>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table>
<thead>
<tr>
<th align="left">索引结构</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B+Tree</td>
<td align="left">最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td align="left">Hash</td>
<td align="left">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td align="left">R-Tree(空间索引)</td>
<td align="left">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td align="left">Full-Text(全文索引)</td>
<td align="left">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">InnoDB</th>
<th align="left">MyISAM</th>
<th align="left">Memory</th>
</tr>
</thead>
<tbody><tr>
<td align="left">B+Tree索引</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">Hash索引</td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">R-Tree索引</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">Full-text</td>
<td align="left">5.6版本后支持</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
</tbody></table>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol>
<li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li>
</ol>
<ul>
<li>相对于二叉树，层级更少，搜索效率高</li>
<li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li>
<li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主键索引</td>
<td align="left">针对于表中主键创建的索引</td>
<td align="left">默认自动创建，只能有一个</td>
<td align="left">PRIMARY</td>
</tr>
<tr>
<td align="left">唯一索引</td>
<td align="left">避免同一个表中某数据列中的值重复</td>
<td align="left">可以有多个</td>
<td align="left">UNIQUE</td>
</tr>
<tr>
<td align="left">常规索引</td>
<td align="left">快速定位特定数据</td>
<td align="left">可以有多个</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">全文索引</td>
<td align="left">全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td align="left">可以有多个</td>
<td align="left">FULLTEXT</td>
</tr>
</tbody></table>
<p>在&#x3D;&#x3D;InnoDB 存储引擎&#x3D;&#x3D;中，根据索引的存储形式，又可以分为以下两种：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">含义</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">聚集索引(Clustered Index)</td>
<td align="left">将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td>
<td align="left">必须有，而且只有一个</td>
</tr>
<tr>
<td align="left">二级索引(Secondary Index)</td>
<td align="left">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td align="left">可以存在多个</td>
</tr>
</tbody></table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引</li>
<li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li>
<li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li>
</ul>
<p>演示图：</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220816211533608.png" alt="image-20220816211533608"></p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220816211539127.png" alt="image-20220816211539127"></p>
<p>mysql存储单元是按页的，一页16K，如上图，一页中由索引字段以及下一页的指针组成，以bigint为例，它是8个字节，一个指针是6字节，则一页能存16KB&#x2F;(8B+6KB) &#x3D; 1170个指针。那第二层则有1170*1170 &#x3D; 1368900个指针，第三层为存数据的，假设一条数据为1K，则一页可以存16条数据，第二层每个指针指向一页，则有16*1368900&#x3D;21902400，也就是两千多万条数据。若再向下分层，则存储跟多数据，但是索引效率就没那么高了，一般采用分库分表。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol>
<li>以下 SQL 语句，哪个执行效率高？为什么？</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;<span class="comment">-- 备注：id为主键，name字段创建的有索引</span></span><br></pre></td></tr></table></figure>

<p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p>
<ol start="2">
<li>InnoDB 主键索引的 B+Tree 高度为多少？</li>
</ol>
<p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>。n * 8为key的空间，(n+1)*6为指针的空间，16*1024为一页的空间，则n&#x3D;1170，为key个数，指针个数为n+1&#x3D;1171</p>
<p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；（每个指针指向一页，每页16行）<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p>
<p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p>
<h3 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p>
<p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p>
<p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p>
<p>案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user (phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为profession, age, status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_stat <span class="keyword">on</span> tb_user(profession, age, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h4><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或</p>
<p><code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code></p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志开关</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p>
<p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p>
<h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。</p>
<p>通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code></p>
<p>查看profiling是否关闭</p>
<p><code>SELECT @@profiling;</code></p>
<p>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code></p>
<p>查看所有语句的耗时：<br><code>show profiles;</code></p>
<p>查看指定query_id的SQL语句各个阶段的耗时：(query_id是show profiles语句执行结果里的)<br><code>show profile for query query_id;</code></p>
<p>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p>
<h4 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h4><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字explain或<span class="keyword">desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 HWERE 条件;</span><br></pre></td></tr></table></figure>

<p>EXPLAIN 各字段含义：</p>
<ul>
<li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li>
<li>select_type：表示 SELECT 的类型，常见取值有  SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li>
<li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li>
<li>possible_key：可能应用在这张表上的索引，一个或多个</li>
<li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li>
<li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li>
<li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li>
<li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li>
</ul>
<h3 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>即对多个列进行索引创建。索引按第一个字段进行比较，若一样则比较第二个字段，依次下去。</p>
<p>根据最左前缀法则，联合索引建立的列顺序是有影响的。</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220828210458002.png" alt="image-20220828210458002"></p>
<h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引使用了多列（联合）索引，查询必须从索引的最左列开始，不能跳过索引的列。</p>
<p>如果跳过了其中一列，则索引后面部分失效。</p>
<p>例，对表t的a，b，c三列建立索引a_b_c_index</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#可以看到key为a_b_c_index，即查询用了索引，索引长度len为n</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> &quot;a&quot; <span class="keyword">and</span> b <span class="operator">=</span> &quot;b&quot; <span class="keyword">and</span> c <span class="operator">=</span> &quot;c&quot;;</span><br><span class="line"></span><br><span class="line">#可以看到key为a_b_c_index，即查询用了索引，索引长度len比n小，即查询a时使用了索引，而查询c时没有，即索引部分失效</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> &quot;a&quot; <span class="keyword">and</span> c <span class="operator">=</span> &quot;c&quot;;</span><br><span class="line"></span><br><span class="line">#可以看到key为<span class="keyword">null</span>，即查询没有用了索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">=</span> &quot;b&quot; <span class="keyword">and</span> c <span class="operator">=</span> &quot;c&quot;;</span><br></pre></td></tr></table></figure>



<h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><ul>
<li><p>对索引列进行运算，索引失效</p>
<p><code>select * from t where substring(a,10,3) = &#39;aaa&#39;</code></p>
</li>
<li><p>字符串列不加引号</p>
<p><code>select * from t wherer a = a</code></p>
</li>
<li><p>模糊查询，头部进行模糊查询</p>
<p><code>select * forom t where a like &#39;%a&#39;</code></p>
</li>
<li><p>or连接的情况，or所有条件中只要有一个没有索引，则所有都不会走索引</p>
</li>
<li><p>若mysql评估走索引比全表慢，则不使用索引</p>
<ul>
<li><code>select * from where a &gt; &#39;较小值&#39;</code>；查询的结果占表的大部分</li>
</ul>
</li>
</ul>
<h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>就是在SQL语句中加入一些人为提示来达到优化的效果。</p>
<p>例如表t的列a有两个索引index1，index2，在使用a条件查询时，数据库会自己使用其中一个索引，我们可以人为指定。</p>
<ul>
<li>use index 建议数据库用这个索引，实际使用不一定，mysql会权衡</li>
<li>ignore index 忽视这个索引</li>
<li>force index 必须用这个索引</li>
</ul>
<p>使用<code>select 列名 from 表名 use/ignore/force(索引名) where ...</code></p>
<h4 id="覆盖索引-回表查询"><a href="#覆盖索引-回表查询" class="headerlink" title="覆盖索引&amp;&amp;回表查询"></a>覆盖索引&amp;&amp;回表查询</h4><p>表t的a列有索引，则</p>
<ul>
<li>&#x3D;&#x3D;覆盖索引&#x3D;&#x3D;：<code>select id,a from t where a = &#39;zzz&#39;</code>，因为a是二级索引，索引叶子是id，则查询id和a都能在索引上查询。</li>
<li>回表查询：<code>select id,a,b from t where a = &#39;zzz&#39;</code>，而b在索引上查询不到，要根据id进行回表查询。</li>
</ul>
<p>可以使用explain查看执行情况。结果Extra字段的结果为：</p>
<ul>
<li>using where，using index ，为覆盖索引查询</li>
<li>using index condition 或 null，为回表查询</li>
</ul>
<p>所以，除非是聚集索引(即条件为主键)，尽量避免<code>select *</code> ，避免回表查询，效率慢。</p>
<p>思考：表t(id,a,b,c)，对<code>select id,a,b from t where a = &#39;z&#39;</code> 进行优化，该如何建索引。</p>
<p>因为条件查询为a列，所以要对a建索引，并且查询列有b，为了避免回表查询，所以要对a，b列进行联合索引。</p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段为vachar或text时，有时存的是文章，建立索引的索引会变得很大，查询效率会降低。所以可以只将字符串截取一部分前缀建立索引。</p>
<p><code>create 索引名 on 表(列(长度n))</code></p>
<p>一般n可以由<code>count(distinct substring(列,1,n)) / count(*)</code>推出，当n截取足够小，且计算接近1，则效果越好。</p>
<ul>
<li>count(distinct substring(列,1,n))，将字符串截取n个后，不同的字符串个数。</li>
</ul>
<img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220828205452351.png" alt="image-20220828205452351" style="zoom:80%;" />

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=85&spm_id_from=pageDriver&vd_source=8519248bd495ba063f1d930a7ef1422e">参考</a></p>
<h3 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h3><p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220828211013937.png" alt="image-20220828211013937"></p>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入insert优化"><a href="#插入insert优化" class="headerlink" title="插入insert优化"></a>插入insert优化</h3><p>我们插入都是一条一条插入，效率不高。可以有下面操作提高效率</p>
<ul>
<li>批量插入：insert into 表 values(1),(2),(3)…; 但一般不要超过1000条；</li>
<li>手动提交事务：开启事务后，逐条插入数据，再提交事务；</li>
<li>主键顺序插入</li>
</ul>
<p><strong>大批量数据插入</strong></p>
<p>如果需要插入大量数据，则insert效率较低，可以使用load指令进行插入</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220829190909968.png" alt="image-20220829190909968"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端连接mysql时，携带参数 --local-infile</span></span><br><span class="line">mysql --local-infile -u root -p</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置全局参数local_infile为1，开启本地加载文件导入数据</span></span><br><span class="line">set global local_infile = 1；</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看</span></span><br><span class="line">select @@local_infile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行load指令将数据加载到表里</span></span><br><span class="line">load data local_infile &#x27;路径&#x27; into table &#x27;表名&#x27; fields terminated by &#x27;,&#x27; lines terminated bt &#x27;\n&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>在InnoDB中，表数据是根据主键顺序组织存放的，这种存储方式的表为&#x3D;&#x3D;索引组织表&#x3D;&#x3D;</p>
<p><img src="https://haiyu-picture-typora.oss-cn-guangzhou.aliyuncs.com/picture-typora/image-20220829191557196.png" alt="image-20220829191557196"></p>
<p>页可以为空，也可以填充一半或100%，每个月包含&#x3D;&#x3D;2-N&#x3D;&#x3D;行数据</p>
<p>若主键乱序插入会产生页分裂。<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90&spm_id_from=pageDriver&vd_source=8519248bd495ba063f1d930a7ef1422e">页分裂和页合并</a></p>
<p><strong>主键设计原则</strong></p>
<ul>
<li>满足业务前提下，尽量降低主键长度</li>
<li>插入数据时，尽量选择顺序插入，选择使用auto_increment自增主键</li>
<li>尽量不要使用UUID或其他自然主键。因为UUID长度长且不是有顺序的。</li>
<li>避免对主键进行修改</li>
</ul>
<h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><ul>
<li>Using filesort：通过索引或者全表扫描，读取满足条件的行，然后在排序缓冲区sort buffer中完成排序操作，&#x3D;&#x3D;所有不是通过索引直接返回排序结果的排序都叫filesort排序&#x3D;&#x3D;。</li>
<li>Using index：通过有序索引顺序扫描直接返回有序数据，不需要额外排序。</li>
</ul>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 对表t的a,b创建索引<span class="number">1</span></span><br><span class="line"><span class="keyword">create</span> index a_b_index1 <span class="keyword">on</span> t(a,b);</span><br><span class="line"></span><br><span class="line"># 查看执行情况，发现Extra为<span class="keyword">Using</span> index</span><br><span class="line">explain <span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> a,b;</span><br><span class="line"></span><br><span class="line"># 查看执行情况，发现Extra为<span class="keyword">Using</span> index 与 <span class="keyword">Using</span> filesort(因为创建索引时先a后b，这里排序是先b后a)</span><br><span class="line">explain <span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> b,a;</span><br><span class="line"></span><br><span class="line"># 查看执行情况，发现Extra为<span class="keyword">Using</span> index 与 backward index scan(因为是倒序排序，所有要反向扫描索引)</span><br><span class="line">explain <span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">desc</span>,phone <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 查看执行情况，发现Extra为<span class="keyword">Using</span> index 与 <span class="keyword">Using</span> filesort(因为创建索引时默认的是都是<span class="keyword">asc</span>)</span><br><span class="line">explain <span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">asc</span>, phone <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 对表t的a,b创建索引<span class="number">2</span></span><br><span class="line"><span class="keyword">create</span> index a_b_index2 <span class="keyword">on</span> t(a <span class="keyword">asc</span>,b <span class="keyword">desc</span>);</span><br><span class="line"></span><br><span class="line"># 查看执行情况，发现Extra为<span class="keyword">Using</span> index</span><br><span class="line">explain <span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">asc</span>, phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>注意上面的查询都是覆盖索引查询。</p>
<p><strong>小结</strong></p>
<ul>
<li>根据排序字段建立合适的索引，多字段排除时，也遵循最左前缀法则</li>
<li>尽量使用覆盖索引</li>
<li>多字段排序，一个升序一个降序，需注意联合索引在创建是的规则</li>
<li>如果不可避免出现filesort，大量数据排序时，可以适当增加缓冲区大小sort_buffer_size（默认256K）</li>
</ul>
<h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p>在分组操作，可以通过索引提高效率，且索引的使用也是满足最左前缀法则。</p>
<p>例,表t的a，b建立联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 结果Extra为<span class="keyword">Using</span> index</span><br><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"># 结果Extra为<span class="keyword">Using</span> index 和 <span class="keyword">Using</span> temporary（使用了临时表）</span><br><span class="line">explain <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">group</span> <span class="keyword">by</span> b</span><br></pre></td></tr></table></figure>



<h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在进行分页操作时，越到后面耗时越高，例：select * from t limit 200000 2，因为要扫描200001条数据后只要2条数据，代价很大。</p>
<p><strong>可以通过覆盖索引和子查询优化</strong></p>
<p><code>select id from t limit 200000 1</code> 通过索引覆盖获取id，作为子查询</p>
<p>然后<code>select * from  t where id in (select id from t limit 200000 1)</code></p>
<p>有点mysql版本不支持上面写法，可以使用连表</p>
<p><code>select t.* from t, (select id from t limit 200000 1) c where t.id = c.id</code></p>
<h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><ul>
<li>MyISAM引擎把一个表的总行数存在了磁盘，执行count(*)的时候直接返回，效率高；</li>
<li>InnoDB引擎执行count(*)时，把数据一行一行从引擎读出，然后累计计数；</li>
</ul>
<p>count几种用法</p>
<ul>
<li>count(主键)<ul>
<li>InnoDB会遍历整张表，把每一行主键&#x3D;&#x3D;取出&#x3D;&#x3D;，返回给服务层，服务按行累加</li>
</ul>
</li>
<li>count(字段)<ul>
<li>没有not null约束：InnoDB会遍历表的每一行的字段值&#x3D;&#x3D;取出&#x3D;&#x3D;，返回给服务层，服务层判断&#x3D;&#x3D;是否为null&#x3D;&#x3D;，不为null则累加；</li>
<li>有not null约束：InnoDB会遍历表的每一行的字段值&#x3D;&#x3D;取出&#x3D;&#x3D;，返回给服务层，服务层累加；</li>
</ul>
</li>
<li>count(n)–例count(1),count(0),count(2)<ul>
<li>InnoDB遍历整张表，但&#x3D;&#x3D;不取值&#x3D;&#x3D;，服务层对于返回的每一行，放一个数字n进去，进行按行累计。</li>
</ul>
</li>
<li>count(*)<ul>
<li>InnoDB不会把字段全部取出，而是专门进行优化，&#x3D;&#x3D;不取值&#x3D;&#x3D;，服务层直接按行进行累加</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;count(*) &gt; count(1) &gt; count(主键) $\approx$ count(字段)&#x3D;&#x3D;</p>
<h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>&#x3D;&#x3D;主要是避免行锁变成表锁&#x3D;&#x3D;</p>
<p>例：表t(id,name)，开启两个终端，各开事务a,b；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a</span></span><br><span class="line">start transaction</span><br><span class="line">update t set name = &#x27;haiyu&#x27; where id = 1; # 更新成功</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a成功更新后还未提交，b更新数据</span></span><br><span class="line">start transaction</span><br><span class="line">update t set name = &#x27;zz&#x27; where id = 2; # 更新成功</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a</span></span><br><span class="line">update t set name = &#x27;yuyy&#x27; where name = &#x27;haiyu&#x27;; # 更新成功</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a成功更新后还未提交，b更新数据</span></span><br><span class="line">update t set name = &#x27;zzz&#x27; where id = 2; # 更新失败</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">a</span></span><br><span class="line">commit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">b</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<p>可以看到a在对name条件查询后更新，b更新name失败，因为name字段没有索引，则变成表锁，当进行条件操作时，会锁住表然后扫表，导致b不能更新。可以为name建立索引，变成行锁，修改时只锁定这一行，不影响其他行更新。</p>
<p>&#x3D;&#x3D;InnoDB行锁是针对索引的，不是针对记录加的锁，并且该索引不能失效，否则会变成表锁。所以条件字段尽量用索引字段&#x3D;&#x3D;</p>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>系统变量是mysql服务器提供的，分为<strong>全局变量GLOBAL</strong> 和 <strong>会话变量SESSION</strong></p>
<p>不知道默认为session</p>
<p>查看系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] VARIABLES;</span><br><span class="line"><span class="keyword">show</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] VARIABLES <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="keyword">show</span> @@[SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>].系统变量名</span><br></pre></td></tr></table></figure>

<p>设置系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>].系统变量名 <span class="operator">=</span> 值；</span><br></pre></td></tr></table></figure>



<h2 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h2><p>是用户根据自己需要定义的变量，不用提前声明，在用的时候直接用<code>@变量名</code>使用，其作用域为当前连接</p>
<p>赋值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name1</span> <span class="operator">=</span> xxx, <span class="variable">@var_name2</span> <span class="operator">=</span> xxx, .....</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name1</span> :<span class="operator">=</span> xxx, <span class="variable">@var_name2</span> :<span class="operator">=</span> xxx, ...</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name1</span> :<span class="operator">=</span> xxx, <span class="variable">@var_name2</span> :<span class="operator">=</span> xxx, ...</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span></span><br></pre></td></tr></table></figure>





<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>就是对<strong>整个数据库</strong>加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>典型的使用场景为做全库的逻辑备份，对所有表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 加锁全局锁</span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份,注意不是sql命令</span></span><br><span class="line">mysqldump -u用户名 -p密码 数据库名 &gt; 路径+文件.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 是否锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<p>问题</p>
<ul>
<li>如果在主库上备份，那么在备份期间不能执行更新，业务基本停止</li>
<li>如果在从库上备份，那么在备份期间不能执行主库同步过来的二进制日志，导致主从延迟</li>
</ul>
<p>在InnoDB中，我们可以在备份时加上参数 –single-transaction来完成&#x3D;&#x3D;不加锁&#x3D;&#x3D;（不用执行加锁和释放锁语句）的一致性数据备份</p>
<p><code>mysqldump --single-transaction -u用户名 -p密码 数据库 &gt; 路径+文件.sql</code></p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>每次操作锁住整张表，锁定粒度大，发送锁冲突的概率最高，并发度最低，应用在MyISAM、InnoDB，BDB中</p>
<p>对于表级锁，主要有三类</p>
<ul>
<li>表锁</li>
<li>元数据锁</li>
<li>意向锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>表共享读锁，所有人只能读不能写</li>
<li>表独占写锁，只有自己能读写，其他人不能读写</li>
</ul>
<p>加锁<code>lock tables 表名... read/write </code></p>
<p>释放锁<code>unlock tables</code></p>
<h4 id="元数据锁（meta-data-lock，MDL）"><a href="#元数据锁（meta-data-lock，MDL）" class="headerlink" title="元数据锁（meta data lock，MDL）"></a>元数据锁（meta data lock，MDL）</h4><p>MDL加锁是由系统自动控制，无需显示使用，在访问张表时会自动加上。主要作用是维护表元数据(表结构)的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。&#x3D;&#x3D;为了避免DML与DDL冲突，保证读写的正确性&#x3D;&#x3D;。</p>
<p>在MySql5.5中引入了MDL，当对一张表进行增删改查时，加MDL<strong>共享读&#x2F;写锁</strong>；当对表结构进行变更时，加MDL<strong>排他锁</strong>。当加上共享锁时，排他锁不能加上，反过来一样。但共享锁里的读锁和写锁是可以同时存在。</p>
<p>例:开启两个事务a,b，a在增删改查时加上了共享锁，b此时也可以加上共享锁进行增删改查，但b不能进行DDL修改表结构，因为要加上排他锁，而a已经对表加上了共享锁，除非a提交事务。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了避DML在执行时，加的行锁与表锁冲突，在InnoDB引入意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>每次操作锁住对应的行，锁定粒度最小，发生锁冲突概率最低，并发度最高。应用在InnoDB中。</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过索引上的索引项加锁来实现的，而不是对记录加的锁，行级锁分为三类。</p>
<ul>
<li><p>行锁：锁定单个行记录的锁，封装其他事务对此进行update和delete。在RC、RR隔离级别下都支持</p>
</li>
<li><p>间隙锁：锁定索引记录的间隙，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</p>
</li>
<li><p>临键锁：行锁和间隙锁组合，在RR隔离级别下都支持</p>
</li>
</ul>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现两种类型的行锁：</p>
<ul>
<li>共享锁（S)：事务加S锁，其他事务可以加S锁，但不能加X锁</li>
<li>排他锁（X)：事务加X锁，其他事务不可用加X和S锁</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>S锁</th>
<th>X锁</th>
</tr>
</thead>
<tbody><tr>
<td><strong>S锁</strong></td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td><strong>X锁</strong></td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>对于insert，delete，update—加的是X锁</p>
<p>select  .. from … where … —不加锁</p>
<p>select … from … where … lock in share mode —加S锁</p>
<p>select .. from … where … for update —加X锁</p>
<p>&#x3D;&#x3D;InnoDB的行锁是针对索引的，即where的条件字段是要有索引的，否则会升级为表锁，对所有记录加锁。&#x3D;&#x3D;</p>
<h4 id="间隙锁GAP"><a href="#间隙锁GAP" class="headerlink" title="间隙锁GAP"></a>间隙锁GAP</h4><p>表t有id为1 和 5的数据，中间没有数据。事务a执行对id为2&#x2F;3&#x2F;4的记录进行修改操作，此时会对id 1~5的间隙添加锁。事务b此时往2&#x2F;3&#x2F;4插入数据，则阻塞。直到a提交事务，释放锁，事务b才插入。</p>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>事务有四大特性：原子性，一致性，隔离性，持久性（ACID）</p>
<p>而 原子性，一致性，持久性底层由 redo.log和undo.log保障</p>
<p>隔离性底层由锁和MVCC保障</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo.log"></a>redo.log</h3><p>重做日志，记录事务提交时数据页的物理修改，是用来实现事务的&#x3D;&#x3D;持久性&#x3D;&#x3D;</p>
<p>由两部分组成：重做日志缓冲（内存中），重做日志文件（磁盘中）。</p>
<p>事务提交后数据是放到缓冲区，然后再刷新到磁盘的。当事务提交后会把所有修改信息都存到该日志文件中，若缓冲区的数据传到磁盘时发送错误，这时日志文件就进行数据恢复使用。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo.log"></a>undo.log</h3><p>回滚日志，用于记录数据被修改前的信息，作用：提供回滚和MVCC</p>
<ul>
<li>当insert时，产生的undo.log只在回滚时需要，在事务提交后，可被立即删除</li>
<li>update，delete，产生的undo.log不仅在回滚时需要，在快照读时也需要，不会立即被删除</li>
</ul>
<h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC-多版本并发控制"></a>MVCC-多版本并发控制</h3><p>指维护一个数据的多个版本，使得读写操作没有冲突，快照读为mysql实现MVCC提供了一个非阻塞读功能。主要依赖于数据库中<strong>记录的三个隐藏字段，undo.log和readView</strong>。</p>
<ul>
<li><p>&#x3D;&#x3D;当前读&#x3D;&#x3D;：读取的都是最新的数据，读的时候会加锁，保证其他事务不会修改当前记录。例如：select .. lock in share mode(共享锁)、select … for update、insert、delete（排他锁），都是当前读</p>
<ul>
<li>比如，InnoDB默认隔离级别是可重复读，即事务读取的都是第一次select的数据，别的事务修改提交后的数据读取不到，可以通过select … lock in share mode等当前读，来读取最新数据。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;快照读&#x3D;&#x3D;：简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，是非阻塞读。</p>
<ul>
<li>read commited：每次select，都生成一个快照读</li>
<li>repeatable read：开启事务后第一个select语句才是快照读的地方</li>
<li>serializable：快照读会退化为当前读</li>
</ul>
</li>
</ul>
<h4 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h4><p>在创建表时，除了我们自己定义的字段，还有三个隐藏的字段</p>
<ul>
<li>DB_TRX_ID：最近修改事务ID，记录插入这条记录或租后一次修改该记录的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指这条记录的上一个版本，用于配合undo.log</li>
<li>DB_ROW_ID：隐藏主键，如果表没有指定主键，将会生成该隐藏字段</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/09/09/mysql%E5%AD%A6%E4%B9%A0/">http://example.com/2022/09/09/mysql%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/09/15/axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/" title="axios二次封装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">axios二次封装</div></div><div class="info-2"><div class="info-item-1">axios二次封装axios请求方式axios的get请求 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get(&#x27;/user?ID=12345&#x27;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);// 上面的请求也可以这样做axios.get(&#x27;/user&#x27;, &#123;    params: &#123;      ID: 12345    &#125;  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error); ...</div></div></div></a><a class="pagination-related" href="/2022/09/09/Linux%E5%AD%A6%E4%B9%A0/" title="Linux学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Linux学习</div></div><div class="info-2"><div class="info-item-1">Linux常用指令关机&amp;重启命令shutdow -h now    或    halt	立即关机 shutdown -h 1 		1分钟过后关机 shutdown -r now  或·   reboot    立即重启 sync		把内存的数据同步到磁盘 &#x3D;&#x3D;注意 ：不管关机还是重启前，都运行一下sync，虽然现在系统会自动帮我们执行sync&#x3D;&#x3D; 用户登录与退出 “logout” 退出用户（注意logout不能在图形级别使用，只能在运行级别3有效）  用户管理添加用户 useradd + 用户名  默认在&#x2F;home目录创建与用户名同名的家目录  useradd -d 指定目录 用户名    指定家目录   指定&#x2F;修改密码 passwd 用户名      给指定用户设置密码  删除用户 userdel 用户名 	删除用户但保留家目录 userdel -r 用户名 删除用户及其家目录  查询用户信息 id 用户名  切换用户 su - 用户名...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Doe</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">常用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">sql执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">事务并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-number">5.1.</span> <span class="toc-text">InnoDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">5.2.</span> <span class="toc-text">MyISAM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">5.3.</span> <span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9"><span class="toc-number">5.4.</span> <span class="toc-text">存储引擎特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">5.5.</span> <span class="toc-text">存储引擎的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">6.2.1.</span> <span class="toc-text">思考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">创建语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1"><span class="toc-number">6.4.1.</span> <span class="toc-text">查看执行频次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">6.4.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#profile"><span class="toc-number">6.4.3.</span> <span class="toc-text">profile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">6.4.4.</span> <span class="toc-text">explain执行计划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">6.5.</span> <span class="toc-text">索引使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">6.5.1.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">6.5.2.</span> <span class="toc-text">最左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">6.5.3.</span> <span class="toc-text">索引失效情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="toc-number">6.5.4.</span> <span class="toc-text">SQL提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.5.5.</span> <span class="toc-text">覆盖索引&amp;&amp;回表查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">6.5.6.</span> <span class="toc-text">前缀索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%BB%BA%E7%AB%8B%E5%8E%9F%E5%88%99"><span class="toc-number">6.6.</span> <span class="toc-text">索引建立原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5insert%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">插入insert优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">order by优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-by%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">group by优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-number">7.6.</span> <span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96"><span class="toc-number">7.7.</span> <span class="toc-text">update优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">9.</span> <span class="toc-text">用户定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">10.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">10.2.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">10.2.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88meta-data-lock%EF%BC%8CMDL%EF%BC%89"><span class="toc-number">10.2.2.</span> <span class="toc-text">元数据锁（meta data lock，MDL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">10.2.3.</span> <span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">10.3.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">10.3.1.</span> <span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81GAP"><span class="toc-number">10.3.2.</span> <span class="toc-text">间隙锁GAP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">11.1.</span> <span class="toc-text">redo.log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">11.2.</span> <span class="toc-text">undo.log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">11.3.</span> <span class="toc-text">MVCC-多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%AD%E7%9A%84%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">11.3.1.</span> <span class="toc-text">记录中的隐藏字段</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/15/springcloud%E5%AD%A6%E4%B9%A0/" title="springcloud笔记">springcloud笔记</a><time datetime="2023-02-15T11:52:38.000Z" title="Created 2023-02-15 19:52:38">2023-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/27/jsr303%E4%BD%BF%E7%94%A8/" title="jsr303使用">jsr303使用</a><time datetime="2022-09-27T01:26:45.000Z" title="Created 2022-09-27 09:26:45">2022-09-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/26/nginx%E4%BB%A3%E7%90%86%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE%E7%BB%86%E8%8A%82/" title="nginx代理路径配置细节">nginx代理路径配置细节</a><time datetime="2022-09-26T08:09:43.000Z" title="Created 2022-09-26 16:09:43">2022-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/20/log%E6%97%A5%E5%BF%97%E4%BD%BF%E7%94%A8/" title="log日志使用">log日志使用</a><time datetime="2022-09-20T07:19:54.000Z" title="Created 2022-09-20 15:19:54">2022-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/16/docker%E5%AD%A6%E4%B9%A0/" title="docker学习">docker学习</a><time datetime="2022-09-16T07:33:51.000Z" title="Created 2022-09-16 15:33:51">2022-09-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>